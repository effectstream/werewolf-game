module Werewolf {
import CompactStandardLibrary;
import CompactStandardLibrary prefix std_;
import "./WerewolfTypes";
import "./Crypto" prefix Crypto_;

// =========================================================================
// WITNESS DECLARATIONS
// =========================================================================

// Witness to fetch a specific player commitment by index during creation (Hash)
export witness wit_getRoleCommitment(gameId: Uint<32>, n: Uint<32>): Bytes<32>;

// Witness to fetch a specific player's encrypted role by index during creation (Bytes<3>)
export witness wit_getEncryptedRole(gameId: Uint<32>, n: Uint<32>): Bytes<3>; 

// Witness to fetch the admin key during creation
export witness wit_getAdminKey(gameId: Uint<32>): ZswapCoinPublicKey;

// Witness to fetch the initial merkle root during creation
export witness wit_getInitialRoot(gameId: Uint<32>): MerkleTreeDigest;

// Witness to fetch voting data (Merkle Proof + Encrypted Vote)
export witness wit_getActionData(gameId: Uint<32>, round: Uint<32>): ActionData;

// =========================================================================
// STATE (Vector<16> = max 16 players)
// =========================================================================

export ledger games: Map<Uint<32>, GameState>;
export ledger playerAlive: Map<Uint<32>, Vector<16, Boolean>>;

// Hashed commitments for Fairness (32 bytes)
export ledger playerRoleCommitments: Map<Uint<32>, Vector<16, Bytes<32>>>;

// Encrypted roles for Player Privacy (3 bytes)
export ledger playerEncryptedRoles: Map<Uint<32>, Vector<16, Bytes<3>>>;

export ledger movesSubmittedCount: Map<Bytes<32>, Uint<32>>;
export ledger voteNullifiers: Set<Bytes<32>>;
export ledger gameSecrets: Map<Uint<32>, Bytes<32>>;

// Encrypted votes for the current round (3 bytes)
export ledger roundEncryptedVotes: Map<Bytes<32>, Vector<16, Bytes<3>>>;

export ledger testOutputMap: Map<Uint<32>, Vector<16, Bytes<32>>>;

// Helpers for dynamic index into Vector (Compact only supports constant indices)
export pure circuit selectBool(v: Vector<16, Boolean>, idx: Uint<32>): Boolean {
    return (idx == 0 as Uint<32>) ? v[0] : (idx == 1 as Uint<32>) ? v[1] : (idx == 2 as Uint<32>) ? v[2] : (idx == 3 as Uint<32>) ? v[3] : (idx == 4 as Uint<32>) ? v[4] : (idx == 5 as Uint<32>) ? v[5] : (idx == 6 as Uint<32>) ? v[6] : (idx == 7 as Uint<32>) ? v[7] : (idx == 8 as Uint<32>) ? v[8] : (idx == 9 as Uint<32>) ? v[9] : (idx == 10 as Uint<32>) ? v[10] : (idx == 11 as Uint<32>) ? v[11] : (idx == 12 as Uint<32>) ? v[12] : (idx == 13 as Uint<32>) ? v[13] : (idx == 14 as Uint<32>) ? v[14] : (idx == 15 as Uint<32>) ? v[15] : v[15];
}
export pure circuit selectBytes32(v: Vector<16, Bytes<32>>, idx: Uint<32>): Bytes<32> {
    return (idx == 0 as Uint<32>) ? v[0] : (idx == 1 as Uint<32>) ? v[1] : (idx == 2 as Uint<32>) ? v[2] : (idx == 3 as Uint<32>) ? v[3] : (idx == 4 as Uint<32>) ? v[4] : (idx == 5 as Uint<32>) ? v[5] : (idx == 6 as Uint<32>) ? v[6] : (idx == 7 as Uint<32>) ? v[7] : (idx == 8 as Uint<32>) ? v[8] : (idx == 9 as Uint<32>) ? v[9] : (idx == 10 as Uint<32>) ? v[10] : (idx == 11 as Uint<32>) ? v[11] : (idx == 12 as Uint<32>) ? v[12] : (idx == 13 as Uint<32>) ? v[13] : (idx == 14 as Uint<32>) ? v[14] : (idx == 15 as Uint<32>) ? v[15] : v[15];
}

export circuit getAdminKey(): ZswapCoinPublicKey {
    return std_ownPublicKey();
}

// =========================================================================
// INITIALIZATION (Merged Setup)
// =========================================================================

export circuit createAndSetupGame(
    gameId: Uint<32>, 
    adminVotePublicKey: Bytes<33>,
    masterSecretCommitment: Bytes<32>,
    actualCount: Uint<32>,
    werewolfCount: Uint<32>
): [] {
    assert(!games.member(gameId), "Game ID already exists");
    assert(actualCount <= 16, "Max players exceeded");

    const adminKey = wit_getAdminKey(gameId);
    const initialRoot = wit_getInitialRoot(gameId);

    // 1. Initialize Game State
    const state = GameState {
        adminKey: disclose(adminKey),
        adminVotePublicKey: adminVotePublicKey,
        phase: Phase.Night,
        round: 1,
        playerCount: actualCount,
        aliveCount: actualCount,
        werewolfCount: werewolfCount,
        villagerCount: (actualCount - werewolfCount) as Uint<32>,
        aliveTreeRoot: disclose(initialRoot),
        masterSecretCommitment: masterSecretCommitment,
        transcriptHash: pad(32, "genesis")
    };
    
    games.insert(gameId, state);

    // 2. Build per-player vectors (max 16 players)
    const empty32 = pad(32, "0");
    const empty3 = pad(3, "0");
    const aliveVec: Vector<16, Boolean> = [
        (0 as Uint<32>) < actualCount, (1 as Uint<32>) < actualCount, (2 as Uint<32>) < actualCount, (3 as Uint<32>) < actualCount,
        (4 as Uint<32>) < actualCount, (5 as Uint<32>) < actualCount, (6 as Uint<32>) < actualCount, (7 as Uint<32>) < actualCount,
        (8 as Uint<32>) < actualCount, (9 as Uint<32>) < actualCount, (10 as Uint<32>) < actualCount, (11 as Uint<32>) < actualCount,
        (12 as Uint<32>) < actualCount, (13 as Uint<32>) < actualCount, (14 as Uint<32>) < actualCount, (15 as Uint<32>) < actualCount
    ];
    const encRoles: Vector<16, Bytes<3>> = [
        (0 as Uint<32>) < actualCount ? disclose(wit_getEncryptedRole(gameId, 0 as Uint<32>)) : empty3,
        (1 as Uint<32>) < actualCount ? disclose(wit_getEncryptedRole(gameId, 1 as Uint<32>)) : empty3,
        (2 as Uint<32>) < actualCount ? disclose(wit_getEncryptedRole(gameId, 2 as Uint<32>)) : empty3,
        (3 as Uint<32>) < actualCount ? disclose(wit_getEncryptedRole(gameId, 3 as Uint<32>)) : empty3,
        (4 as Uint<32>) < actualCount ? disclose(wit_getEncryptedRole(gameId, 4 as Uint<32>)) : empty3,
        (5 as Uint<32>) < actualCount ? disclose(wit_getEncryptedRole(gameId, 5 as Uint<32>)) : empty3,
        (6 as Uint<32>) < actualCount ? disclose(wit_getEncryptedRole(gameId, 6 as Uint<32>)) : empty3,
        (7 as Uint<32>) < actualCount ? disclose(wit_getEncryptedRole(gameId, 7 as Uint<32>)) : empty3,
        (8 as Uint<32>) < actualCount ? disclose(wit_getEncryptedRole(gameId, 8 as Uint<32>)) : empty3,
        (9 as Uint<32>) < actualCount ? disclose(wit_getEncryptedRole(gameId, 9 as Uint<32>)) : empty3,
        (10 as Uint<32>) < actualCount ? disclose(wit_getEncryptedRole(gameId, 10 as Uint<32>)) : empty3,
        (11 as Uint<32>) < actualCount ? disclose(wit_getEncryptedRole(gameId, 11 as Uint<32>)) : empty3,
        (12 as Uint<32>) < actualCount ? disclose(wit_getEncryptedRole(gameId, 12 as Uint<32>)) : empty3,
        (13 as Uint<32>) < actualCount ? disclose(wit_getEncryptedRole(gameId, 13 as Uint<32>)) : empty3,
        (14 as Uint<32>) < actualCount ? disclose(wit_getEncryptedRole(gameId, 14 as Uint<32>)) : empty3,
        (15 as Uint<32>) < actualCount ? disclose(wit_getEncryptedRole(gameId, 15 as Uint<32>)) : empty3
    ];
    const commitmentsVec: Vector<16, Bytes<32>> = [
        (0 as Uint<32>) < actualCount ? disclose(wit_getRoleCommitment(gameId, 0 as Uint<32>)) : empty32,
        (1 as Uint<32>) < actualCount ? disclose(wit_getRoleCommitment(gameId, 1 as Uint<32>)) : empty32,
        (2 as Uint<32>) < actualCount ? disclose(wit_getRoleCommitment(gameId, 2 as Uint<32>)) : empty32,
        (3 as Uint<32>) < actualCount ? disclose(wit_getRoleCommitment(gameId, 3 as Uint<32>)) : empty32,
        (4 as Uint<32>) < actualCount ? disclose(wit_getRoleCommitment(gameId, 4 as Uint<32>)) : empty32,
        (5 as Uint<32>) < actualCount ? disclose(wit_getRoleCommitment(gameId, 5 as Uint<32>)) : empty32,
        (6 as Uint<32>) < actualCount ? disclose(wit_getRoleCommitment(gameId, 6 as Uint<32>)) : empty32,
        (7 as Uint<32>) < actualCount ? disclose(wit_getRoleCommitment(gameId, 7 as Uint<32>)) : empty32,
        (8 as Uint<32>) < actualCount ? disclose(wit_getRoleCommitment(gameId, 8 as Uint<32>)) : empty32,
        (9 as Uint<32>) < actualCount ? disclose(wit_getRoleCommitment(gameId, 9 as Uint<32>)) : empty32,
        (10 as Uint<32>) < actualCount ? disclose(wit_getRoleCommitment(gameId, 10 as Uint<32>)) : empty32,
        (11 as Uint<32>) < actualCount ? disclose(wit_getRoleCommitment(gameId, 11 as Uint<32>)) : empty32,
        (12 as Uint<32>) < actualCount ? disclose(wit_getRoleCommitment(gameId, 12 as Uint<32>)) : empty32,
        (13 as Uint<32>) < actualCount ? disclose(wit_getRoleCommitment(gameId, 13 as Uint<32>)) : empty32,
        (14 as Uint<32>) < actualCount ? disclose(wit_getRoleCommitment(gameId, 14 as Uint<32>)) : empty32,
        (15 as Uint<32>) < actualCount ? disclose(wit_getRoleCommitment(gameId, 15 as Uint<32>)) : empty32
    ];
    playerAlive.insert(gameId, aliveVec);
    playerEncryptedRoles.insert(gameId, encRoles);
    playerRoleCommitments.insert(gameId, commitmentsVec);
}

// =========================================================================
// NIGHT PHASE
// =========================================================================

export circuit submitNightAction(
    _gameId: Uint<32>
): [] {
    const gameId = disclose(_gameId);
    const state = games.lookup(gameId);
    assert(state.phase == Phase.Night, "Not Night phase");

    // 1. Get Data from Witness
    const actionData = wit_getActionData(gameId, state.round);
    const encryptedAction = disclose(actionData.encryptedAction);
    const merklePath = disclose(actionData.merklePath);
    const leafSecret = disclose(actionData.leafSecret);

    // 2. Prove Alive
    const leaf = Crypto_hash(leafSecret);
    assert(Crypto_verifyMerkleProof(state.aliveTreeRoot, leaf, merklePath), "Invalid Merkle Proof or Player Dead");

    // 3. Nullifier Check
    const gameIdBytes = std_persistentHash<Uint<32>>(gameId);
    const nullifier = Crypto_hash2(
        gameIdBytes, 
        Crypto_hash2(std_persistentHash<Uint<32>>(state.round), leafSecret)
    );
    assert(!voteNullifiers.member(nullifier), "Action already submitted");
    voteNullifiers.insert(nullifier);

    // 4. Update Transcript & Ledger
    // Hash the 3-byte encrypted action for the transcript
    const encryptedHash = std_persistentHash<Bytes<3>>(encryptedAction);
    const newTranscript = Crypto_hash2(state.transcriptHash, encryptedHash);

    const countKey = Crypto_hash2(Crypto_hash2(gameIdBytes, pad(32, "night-round")), std_persistentHash<Uint<32>>(state.round));
    const currentCount = movesSubmittedCount.member(countKey) ? movesSubmittedCount.lookup(countKey) : 0 as Uint<32>;
    const empty3 = pad(3, "0");
    const emptyVotes16: Vector<16, Bytes<3>> = [empty3, empty3, empty3, empty3, empty3, empty3, empty3, empty3, empty3, empty3, empty3, empty3, empty3, empty3, empty3, empty3];
    const oldVotes = roundEncryptedVotes.member(countKey) ? roundEncryptedVotes.lookup(countKey) : emptyVotes16;
    const newVotes: Vector<16, Bytes<3>> = [
        (currentCount == 0 as Uint<32>) ? encryptedAction : oldVotes[0], 
        (currentCount == 1 as Uint<32>) ? encryptedAction : oldVotes[1],
        (currentCount == 2 as Uint<32>) ? encryptedAction : oldVotes[2], 
        (currentCount == 3 as Uint<32>) ? encryptedAction : oldVotes[3],
        (currentCount == 4 as Uint<32>) ? encryptedAction : oldVotes[4], 
        (currentCount == 5 as Uint<32>) ? encryptedAction : oldVotes[5],
        (currentCount == 6 as Uint<32>) ? encryptedAction : oldVotes[6], 
        (currentCount == 7 as Uint<32>) ? encryptedAction : oldVotes[7],
        (currentCount == 8 as Uint<32>) ? encryptedAction : oldVotes[8], 
        (currentCount == 9 as Uint<32>) ? encryptedAction : oldVotes[9],
        (currentCount == 10 as Uint<32>) ? encryptedAction : oldVotes[10], 
        (currentCount == 11 as Uint<32>) ? encryptedAction : oldVotes[11],
        (currentCount == 12 as Uint<32>) ? encryptedAction : oldVotes[12], 
        (currentCount == 13 as Uint<32>) ? encryptedAction : oldVotes[13],
        (currentCount == 14 as Uint<32>) ? encryptedAction : oldVotes[14], 
        (currentCount == 15 as Uint<32>) ? encryptedAction : oldVotes[15]
    ];
    roundEncryptedVotes.insert(countKey, newVotes);
    movesSubmittedCount.insert(countKey, (currentCount + 1) as Uint<32>);

    // Save State
    games.insert(gameId, GameState {
        ...state,
        transcriptHash: newTranscript
    });
}

export circuit resolveNight(
    _gameId: Uint<32>,
    _newRound: Uint<32>,
    _deadPlayerIdx: Uint<32>, 
    _hasDeath: Boolean,
    _newMerkleRoot: MerkleTreeDigest
): [] {
    const gameId = disclose(_gameId);
    const newRound = disclose(_newRound);
    const deadPlayerIdx = disclose(_deadPlayerIdx);
    const hasDeath = disclose(_hasDeath);
    const newMerkleRoot = disclose(_newMerkleRoot);

    const state = games.lookup(gameId);
    
    assert(std_ownPublicKey() == state.adminKey, "Only Admin can resolve");
    
    if (hasDeath) {
        const alive = playerAlive.lookup(gameId);
        assert(selectBool(alive, deadPlayerIdx), "Player already dead");
        const newAlive: Vector<16, Boolean> = [
            hasDeath && (deadPlayerIdx == 0 as Uint<32>) ? false : alive[0], 
            hasDeath && (deadPlayerIdx == 1 as Uint<32>) ? false : alive[1],
            hasDeath && (deadPlayerIdx == 2 as Uint<32>) ? false : alive[2], 
            hasDeath && (deadPlayerIdx == 3 as Uint<32>) ? false : alive[3],
            hasDeath && (deadPlayerIdx == 4 as Uint<32>) ? false : alive[4], 
            hasDeath && (deadPlayerIdx == 5 as Uint<32>) ? false : alive[5],
            hasDeath && (deadPlayerIdx == 6 as Uint<32>) ? false : alive[6], 
            hasDeath && (deadPlayerIdx == 7 as Uint<32>) ? false : alive[7],
            hasDeath && (deadPlayerIdx == 8 as Uint<32>) ? false : alive[8], 
            hasDeath && (deadPlayerIdx == 9 as Uint<32>) ? false : alive[9],
            hasDeath && (deadPlayerIdx == 10 as Uint<32>) ? false : alive[10], 
            hasDeath && (deadPlayerIdx == 11 as Uint<32>) ? false : alive[11],
            hasDeath && (deadPlayerIdx == 12 as Uint<32>) ? false : alive[12], 
            hasDeath && (deadPlayerIdx == 13 as Uint<32>) ? false : alive[13],
            hasDeath && (deadPlayerIdx == 14 as Uint<32>) ? false : alive[14], 
            hasDeath && (deadPlayerIdx == 15 as Uint<32>) ? false : alive[15]
        ];
        playerAlive.insert(gameId, newAlive);
    }

    const outcomeHash = std_persistentHash<[Uint<32>, Boolean]>([deadPlayerIdx, hasDeath]);
    const newTranscript = Crypto_hash2(state.transcriptHash, outcomeHash);

    const newState = GameState {
        adminKey: state.adminKey,
        adminVotePublicKey: state.adminVotePublicKey,
        phase: Phase.Day,
        round: state.round, 
        playerCount: state.playerCount,
        aliveCount: hasDeath ? (state.aliveCount - 1) as Uint<32> : state.aliveCount,
        werewolfCount: state.werewolfCount, 
        villagerCount: state.villagerCount, 
        aliveTreeRoot: newMerkleRoot,
        masterSecretCommitment: state.masterSecretCommitment,
        transcriptHash: newTranscript
    };
    games.insert(gameId, newState);
}

// =========================================================================
// DAY PHASE
// =========================================================================

export circuit castDayVote(
    _gameId: Uint<32>
): [] {
    const gameId = disclose(_gameId);
    const state = games.lookup(gameId);
    assert(state.phase == Phase.Day, "Not Day phase");

    // 1. Get Data from Witness
    const actionData = wit_getActionData(gameId, state.round);
    const encryptedVote = disclose(actionData.encryptedAction);
    const merklePath = disclose(actionData.merklePath);
    const leafSecret = disclose(actionData.leafSecret);

    // 2. Prove Alive
    const leaf = Crypto_hash(leafSecret);
    assert(Crypto_verifyMerkleProof(state.aliveTreeRoot, leaf, merklePath), "Invalid Merkle Proof");

    // 3. Nullifier Check
    const gameIdBytes = std_persistentHash<Uint<32>>(gameId);
    const nullifier = Crypto_hash2(
        Crypto_hash2(gameIdBytes, pad(32, "day-vote")),
        Crypto_hash2(std_persistentHash<Uint<32>>(state.round), leafSecret)
    );
    assert(!voteNullifiers.member(nullifier), "Double voting detected");
    voteNullifiers.insert(nullifier);

    // 4. Update Transcript & Ledger
    // Hash the 3-byte encrypted action for the transcript
    const encryptedHash = std_persistentHash<Bytes<3>>(encryptedVote);
    const newTranscript = Crypto_hash2(state.transcriptHash, encryptedHash);

    const countKey = Crypto_hash2(
        Crypto_hash2(gameIdBytes, pad(32, "day-round")), 
        std_persistentHash<Uint<32>>(state.round)
    );
    
    const currentCount = movesSubmittedCount.member(countKey) ? movesSubmittedCount.lookup(countKey) : 0 as Uint<32>;
    const empty3 = pad(3, "0");
    const emptyVotes16: Vector<16, Bytes<3>> = [empty3, empty3, empty3, empty3, empty3, empty3, empty3, empty3, empty3, empty3, empty3, empty3, empty3, empty3, empty3, empty3];
    const oldVotes = roundEncryptedVotes.member(countKey) ? roundEncryptedVotes.lookup(countKey) : emptyVotes16;
    const newVotes: Vector<16, Bytes<3>> = [
        (currentCount == 0 as Uint<32>) ? encryptedVote : oldVotes[0], 
        (currentCount == 1 as Uint<32>) ? encryptedVote : oldVotes[1],
        (currentCount == 2 as Uint<32>) ? encryptedVote : oldVotes[2], 
        (currentCount == 3 as Uint<32>) ? encryptedVote : oldVotes[3],
        (currentCount == 4 as Uint<32>) ? encryptedVote : oldVotes[4], 
        (currentCount == 5 as Uint<32>) ? encryptedVote : oldVotes[5],
        (currentCount == 6 as Uint<32>) ? encryptedVote : oldVotes[6], 
        (currentCount == 7 as Uint<32>) ? encryptedVote : oldVotes[7],
        (currentCount == 8 as Uint<32>) ? encryptedVote : oldVotes[8], 
        (currentCount == 9 as Uint<32>) ? encryptedVote : oldVotes[9],
        (currentCount == 10 as Uint<32>) ? encryptedVote : oldVotes[10], 
        (currentCount == 11 as Uint<32>) ? encryptedVote : oldVotes[11],
        (currentCount == 12 as Uint<32>) ? encryptedVote : oldVotes[12], 
        (currentCount == 13 as Uint<32>) ? encryptedVote : oldVotes[13],
        (currentCount == 14 as Uint<32>) ? encryptedVote : oldVotes[14], 
        (currentCount == 15 as Uint<32>) ? encryptedVote : oldVotes[15]
    ];
    roundEncryptedVotes.insert(countKey, newVotes);
    movesSubmittedCount.insert(countKey, (currentCount + 1) as Uint<32>);

    games.insert(gameId, GameState {
        ...state,
        transcriptHash: newTranscript
    });
}

export circuit resolveDay(
    _gameId: Uint<32>,
    _eliminatedIdx: Uint<32>,
    _hasElimination: Boolean
): [] {
    const gameId = disclose(_gameId);
    const eliminatedIdx = disclose(_eliminatedIdx);
    const hasElimination = disclose(_hasElimination);

    const state = games.lookup(gameId);
    assert(std_ownPublicKey() == state.adminKey, "Only Admin");

    if (hasElimination) {
        const alive = playerAlive.lookup(gameId);
        const newAlive: Vector<16, Boolean> = [
            hasElimination && (eliminatedIdx == 0 as Uint<32>) ? false : alive[0], 
            hasElimination && (eliminatedIdx == 1 as Uint<32>) ? false : alive[1],
            hasElimination && (eliminatedIdx == 2 as Uint<32>) ? false : alive[2], 
            hasElimination && (eliminatedIdx == 3 as Uint<32>) ? false : alive[3],
            hasElimination && (eliminatedIdx == 4 as Uint<32>) ? false : alive[4], 
            hasElimination && (eliminatedIdx == 5 as Uint<32>) ? false : alive[5],
            hasElimination && (eliminatedIdx == 6 as Uint<32>) ? false : alive[6], 
            hasElimination && (eliminatedIdx == 7 as Uint<32>) ? false : alive[7],
            hasElimination && (eliminatedIdx == 8 as Uint<32>) ? false : alive[8], 
            hasElimination && (eliminatedIdx == 9 as Uint<32>) ? false : alive[9],
            hasElimination && (eliminatedIdx == 10 as Uint<32>) ? false : alive[10], 
            hasElimination && (eliminatedIdx == 11 as Uint<32>) ? false : alive[11],
            hasElimination && (eliminatedIdx == 12 as Uint<32>) ? false : alive[12], 
            hasElimination && (eliminatedIdx == 13 as Uint<32>) ? false : alive[13],
            hasElimination && (eliminatedIdx == 14 as Uint<32>) ? false : alive[14], 
            hasElimination && (eliminatedIdx == 15 as Uint<32>) ? false : alive[15]
        ];
        playerAlive.insert(gameId, newAlive);
    }

    const outcomeHash = std_persistentHash<[Uint<32>, Boolean]>([eliminatedIdx, hasElimination]);
    const newTranscript = Crypto_hash2(state.transcriptHash, outcomeHash);

    const nextRound = (state.round + 1) as Uint<32>;
    const newState = GameState {
        adminKey: state.adminKey,
        adminVotePublicKey: state.adminVotePublicKey,
        phase: Phase.Night,
        round: nextRound,
        playerCount: state.playerCount,
        aliveCount: hasElimination ? (state.aliveCount - 1) as Uint<32> : state.aliveCount,
        werewolfCount: state.werewolfCount,
        villagerCount: state.villagerCount,
        aliveTreeRoot: state.aliveTreeRoot,
        masterSecretCommitment: state.masterSecretCommitment,
        transcriptHash: newTranscript
    };
    games.insert(gameId, newState);
}

// =========================================================================
// GAME END & VERIFICATION
// =========================================================================

export circuit revealRole(
    _gameId: Uint<32>,
    _playerIdx: Uint<32>,
    _role: Uint<8>,
    _salt: Bytes<32>
): [] {
    const gameId = disclose(_gameId);
    const playerIdx = disclose(_playerIdx);
    const role = disclose(_role);
    const salt = disclose(_salt);

    const state = games.lookup(gameId);
    const roleCommitment = selectBytes32(playerRoleCommitments.lookup(gameId), playerIdx);

    const calcCommit = Crypto_commitRole(role, salt);
    assert(calcCommit == roleCommitment, "Invalid role revelation");

    if (state.phase != Phase.Finished) {
        const roleEnum = role as Role;
        const isWolf = roleEnum == Role.Werewolf;
        
        const wwCount = isWolf 
            ? ((state.werewolfCount > 0 as Uint<32>) ? (state.werewolfCount - 1 as Uint<32>) : 0 as Uint<32>)
            : state.werewolfCount;

        const vilCount = !isWolf
            ? ((state.villagerCount > 0 as Uint<32>) ? (state.villagerCount - 1 as Uint<32>) : 0 as Uint<32>)
            : state.villagerCount;
        
        const isGameOver = (wwCount == 0 as Uint<32>) || (wwCount >= vilCount);
        const nextPhase = isGameOver ? Phase.Finished : state.phase;

        games.insert(disclose(gameId), GameState {
            ...state,
            phase: nextPhase,
            werewolfCount: wwCount,
            villagerCount: vilCount
        });
    }
}

export circuit endGame(
    _gameId: Uint<32>,
    _masterSecret: Bytes<32>
): [] {
    const gameId = disclose(_gameId);
    const masterSecret = disclose(_masterSecret);

    const state = games.lookup(gameId);
    assert(std_ownPublicKey() == state.adminKey, "Only Admin");

    // Verify Secret against Commitment made in initGame
    const calculatedCommit = Crypto_hash(masterSecret);
    assert(calculatedCommit == state.masterSecretCommitment, "Invalid Master Secret for this Game");

    gameSecrets.insert(gameId, masterSecret);
    
    games.insert(disclose(gameId), GameState {
        ...state,
        phase: Phase.Finished
    });
}

export circuit verifyGameSetup(
    _gameId: Uint<32>,
    _masterSecret: Bytes<32>,
    _playerIdx: Uint<32>,
    _assignedRole: Uint<8>
): Boolean {
    const gameId = disclose(_gameId);
    const masterSecret = disclose(_masterSecret);
    const playerIdx = disclose(_playerIdx);
    const assignedRole = disclose(_assignedRole);

    const state = games.lookup(gameId);
    
    // Check secret is valid for this game
    const calculatedCommit = Crypto_hash(masterSecret);
    if (calculatedCommit != state.masterSecretCommitment) return false;

    const saltSeed = std_persistentHash<[Bytes<32>, Bytes<32>, Uint<32>]>([
        masterSecret, 
        pad(32, "salt"), 
        playerIdx
    ]);
    const derivedSalt = saltSeed;

    const roleCommitment = selectBytes32(playerRoleCommitments.lookup(gameId), playerIdx);
    const derivedCommit = Crypto_commitRole(assignedRole, derivedSalt);

    return derivedCommit == roleCommitment;
}

export circuit getEncryptedVotesForRound(
    _gameId: Uint<32>,
    _phase: Phase,
    _round: Uint<32>
): Vector<16, Bytes<3>> {
    const gameId = disclose(_gameId);
    const phase = disclose(_phase);
    const round = disclose(_round);

    const roundPrefix = phase == Phase.Day ? pad(32, "day-round") : pad(32, "night-round");
    const gameIdBytes = std_persistentHash<Uint<32>>(gameId);
    const countKey = Crypto_hash2(
        Crypto_hash2(gameIdBytes, roundPrefix),
        std_persistentHash<Uint<32>>(round)
    );

    const emptyVote = pad(3, "0");
    if (!roundEncryptedVotes.member(countKey)) {
        return [emptyVote, emptyVote, emptyVote, emptyVote, emptyVote, emptyVote, emptyVote, emptyVote,
                emptyVote, emptyVote, emptyVote, emptyVote, emptyVote, emptyVote, emptyVote, emptyVote];
    }
    const votes = roundEncryptedVotes.lookup(countKey);
    return [votes[0], votes[1], votes[2], votes[3], votes[4], votes[5], votes[6], votes[7],
            votes[8], votes[9], votes[10], votes[11], votes[12], votes[13], votes[14], votes[15]];
}

export circuit getGameAdminPublicKey(_gameId: Uint<32>): Bytes<33> {
    const gameId = disclose(_gameId);
    assert(games.member(gameId), "Game not found");
    return games.lookup(gameId).adminVotePublicKey;
}

}