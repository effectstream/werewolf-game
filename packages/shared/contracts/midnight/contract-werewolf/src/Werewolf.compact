module Werewolf {
import CompactStandardLibrary;
import CompactStandardLibrary prefix std_;
import "./WerewolfTypes";
import "./Crypto" prefix Crypto_;

// =========================================================================
// WITNESS DECLARATIONS
// =========================================================================

// Witness to fetch a specific player commitment by index during creation (Hash)
export witness wit_getRoleCommitment(gameId: Bytes<32>, n: Uint<32>): Bytes<32>;

// Witness to fetch a specific player's encrypted role by index during creation (Bytes<3>)
export witness wit_getEncryptedRole(gameId: Bytes<32>, n: Uint<32>): Bytes<3>; 

// Witness to fetch the admin key during creation
export witness wit_getAdminKey(gameId: Bytes<32>): ZswapCoinPublicKey;

// Witness to fetch the initial merkle root during creation
export witness wit_getInitialRoot(gameId: Bytes<32>): MerkleTreeDigest;

// Witness to fetch voting data (Merkle Proof + Encrypted Vote)
export witness wit_getActionData(gameId: Bytes<32>, round: Uint<32>): ActionData;

// =========================================================================
// STATE
// =========================================================================

export ledger games: Map<Bytes<32>, GameState>;
export ledger playerAlive: Map<Bytes<32>, Map<Uint<32>, Boolean>>;

// Hashed commitments for Fairness (32 bytes)
export ledger playerRoleCommitments: Map<Bytes<32>, Map<Uint<32>, Bytes<32>>>;

// Encrypted roles for Player Privacy (3 bytes)
// This serves as the "mailbox" for players to read their roles on-chain
export ledger playerEncryptedRoles: Map<Bytes<32>, Map<Uint<32>, Bytes<3>>>;

export ledger movesSubmittedCount: Map<Bytes<32>, Uint<32>>;
export ledger voteNullifiers: Set<Bytes<32>>;
export ledger gameSecrets: Map<Bytes<32>, Bytes<32>>;

// Encrypted votes for the current round (3 bytes)
export ledger roundEncryptedVotes: Map<Bytes<32>, Map<Uint<32>, Bytes<3>>>;

export ledger testOutputMap: Map<Bytes<32>, Map<Uint<32>, Bytes<32>>>;

export circuit getAdminKey(): ZswapCoinPublicKey {
    return std_ownPublicKey();
}

// =========================================================================
// INITIALIZATION (Merged Setup)
// =========================================================================

export circuit createAndSetupGame(
    gameId: Bytes<32>, 
    adminVotePublicKey: Bytes<33>,
    masterSecretCommitment: Bytes<32>,
    actualCount: Uint<32>,
    werewolfCount: Uint<32>
): [] {
    assert(!games.member(gameId), "Game ID already exists");
    // We limit to 10 for the vector size in SetupData logic (though struct is gone, game logic assumes 10 max)
    assert(actualCount <= 10, "Max players exceeded");

    const adminKey = wit_getAdminKey(gameId);
    const initialRoot = wit_getInitialRoot(gameId);

    // 1. Initialize Game State
    const state = GameState {
        adminKey: disclose(adminKey),
        adminVotePublicKey: adminVotePublicKey,
        phase: Phase.Night,
        round: 1,
        playerCount: actualCount,
        aliveCount: actualCount,
        werewolfCount: werewolfCount,
        villagerCount: (actualCount - werewolfCount) as Uint<32>,
        aliveTreeRoot: disclose(initialRoot),
        masterSecretCommitment: masterSecretCommitment,
        transcriptHash: pad(32, "genesis")
    };
    
    games.insert(gameId, state);

    playerRoleCommitments.insertDefault(gameId);
    playerEncryptedRoles.insertDefault(gameId);
    playerAlive.insertDefault(gameId);

    // 2. Iterate and register players
    // Compact loops must be constant range, so we loop max (10) and check count
    for (const i of 0..10) {
         if (i < actualCount) {
            const idx = i as Uint<32>;

            // A. Fairness: Store Hash Commitment (32 bytes)
            // const commitment = wit_getRoleCommitment(gameId, idx);
            // playerRoleCommitments.lookup(gameId).insert(
            //     disclose(idx), 
            //     disclose(commitment)
            // );

            // B. Privacy: Store Encrypted Role (3 bytes)
            // Admin calculates this off-chain using [AdminPriv, PlayerPub]
            const encRole = wit_getEncryptedRole(gameId, idx);
            playerEncryptedRoles.lookup(gameId).insert(
                disclose(idx),
                disclose(encRole)
            );

            // C. Set Alive
            playerAlive.lookup(gameId).insert(idx, true);
         }
    }
}

// =========================================================================
// NIGHT PHASE
// =========================================================================

export circuit submitNightAction(
    _gameId: Bytes<32>
): [] {
    const gameId = disclose(_gameId);
    const state = games.lookup(gameId);
    assert(state.phase == Phase.Night, "Not Night phase");

    // 1. Get Data from Witness
    const actionData = wit_getActionData(gameId, state.round);
    const encryptedAction = disclose(actionData.encryptedAction);
    const merklePath = disclose(actionData.merklePath);
    const leafSecret = disclose(actionData.leafSecret);

    // 2. Prove Alive
    const leaf = Crypto_hash(leafSecret);
    assert(Crypto_verifyMerkleProof(state.aliveTreeRoot, leaf, merklePath), "Invalid Merkle Proof or Player Dead");

    // 3. Nullifier Check
    const nullifier = Crypto_hash2(
        gameId, 
        Crypto_hash2(std_persistentHash<Uint<32>>(state.round), leafSecret)
    );
    assert(!voteNullifiers.member(nullifier), "Action already submitted");
    voteNullifiers.insert(nullifier);

    // 4. Update Transcript & Ledger
    // Hash the 3-byte encrypted action for the transcript
    const encryptedHash = std_persistentHash<Bytes<3>>(encryptedAction);
    const newTranscript = Crypto_hash2(state.transcriptHash, encryptedHash);

    const countKey = Crypto_hash2(Crypto_hash2(gameId, pad(32, "night-round")), std_persistentHash<Uint<32>>(state.round));
    const currentCount = movesSubmittedCount.member(countKey) ? movesSubmittedCount.lookup(countKey) : 0 as Uint<32>;
    
    if (!roundEncryptedVotes.member(countKey)) {
        roundEncryptedVotes.insertDefault(countKey);
    }
    roundEncryptedVotes.lookup(countKey).insert(currentCount, encryptedAction);
    movesSubmittedCount.insert(countKey, (currentCount + 1) as Uint<32>);

    // Save State
    games.insert(gameId, GameState {
        ...state,
        transcriptHash: newTranscript
    });
}

export circuit resolveNight(
    _gameId: Bytes<32>,
    _newRound: Uint<32>,
    _deadPlayerIdx: Uint<32>, 
    _hasDeath: Boolean,
    _newMerkleRoot: MerkleTreeDigest
): [] {
    const gameId = disclose(_gameId);
    const newRound = disclose(_newRound);
    const deadPlayerIdx = disclose(_deadPlayerIdx);
    const hasDeath = disclose(_hasDeath);
    const newMerkleRoot = disclose(_newMerkleRoot);

    const state = games.lookup(gameId);
    
    assert(std_ownPublicKey() == state.adminKey, "Only Admin can resolve");
    
    if (hasDeath) {
         assert(playerAlive.lookup(gameId).lookup(deadPlayerIdx), "Player already dead");
         playerAlive.lookup(gameId).insert(deadPlayerIdx, false);
    }

    const outcomeHash = std_persistentHash<[Uint<32>, Boolean]>([deadPlayerIdx, hasDeath]);
    const newTranscript = Crypto_hash2(state.transcriptHash, outcomeHash);

    const newState = GameState {
        adminKey: state.adminKey,
        adminVotePublicKey: state.adminVotePublicKey,
        phase: Phase.Day,
        round: state.round, 
        playerCount: state.playerCount,
        aliveCount: hasDeath ? (state.aliveCount - 1) as Uint<32> : state.aliveCount,
        werewolfCount: state.werewolfCount, 
        villagerCount: state.villagerCount, 
        aliveTreeRoot: newMerkleRoot,
        masterSecretCommitment: state.masterSecretCommitment,
        transcriptHash: newTranscript
    };
    games.insert(gameId, newState);
}

// =========================================================================
// DAY PHASE
// =========================================================================

export circuit castDayVote(
    _gameId: Bytes<32>
): [] {
    const gameId = disclose(_gameId);
    const state = games.lookup(gameId);
    assert(state.phase == Phase.Day, "Not Day phase");

    // 1. Get Data from Witness
    const actionData = wit_getActionData(gameId, state.round);
    const encryptedVote = disclose(actionData.encryptedAction);
    const merklePath = disclose(actionData.merklePath);
    const leafSecret = disclose(actionData.leafSecret);

    // 2. Prove Alive
    const leaf = Crypto_hash(leafSecret);
    assert(Crypto_verifyMerkleProof(state.aliveTreeRoot, leaf, merklePath), "Invalid Merkle Proof");

    // 3. Nullifier Check
    const nullifier = Crypto_hash2(
        Crypto_hash2(gameId, pad(32, "day-vote")),
        Crypto_hash2(std_persistentHash<Uint<32>>(state.round), leafSecret)
    );
    assert(!voteNullifiers.member(nullifier), "Double voting detected");
    voteNullifiers.insert(nullifier);

    // 4. Update Transcript & Ledger
    // Hash the 3-byte encrypted action for the transcript
    const encryptedHash = std_persistentHash<Bytes<3>>(encryptedVote);
    const newTranscript = Crypto_hash2(state.transcriptHash, encryptedHash);

    const countKey = Crypto_hash2(
        Crypto_hash2(gameId, pad(32, "day-round")), 
        std_persistentHash<Uint<32>>(state.round)
    );
    
    const currentCount = movesSubmittedCount.member(countKey) ? movesSubmittedCount.lookup(countKey) : 0 as Uint<32>;
    if (!roundEncryptedVotes.member(countKey)) {
        roundEncryptedVotes.insertDefault(countKey);
    }
    roundEncryptedVotes.lookup(countKey).insert(currentCount, encryptedVote);
    movesSubmittedCount.insert(countKey, (currentCount + 1) as Uint<32>);

    games.insert(gameId, GameState {
        ...state,
        transcriptHash: newTranscript
    });
}

export circuit resolveDay(
    _gameId: Bytes<32>,
    _eliminatedIdx: Uint<32>,
    _hasElimination: Boolean
): [] {
    const gameId = disclose(_gameId);
    const eliminatedIdx = disclose(_eliminatedIdx);
    const hasElimination = disclose(_hasElimination);

    const state = games.lookup(gameId);
    assert(std_ownPublicKey() == state.adminKey, "Only Admin");

    if (hasElimination) {
        playerAlive.lookup(gameId).insert(eliminatedIdx, false);
    }

    const outcomeHash = std_persistentHash<[Uint<32>, Boolean]>([eliminatedIdx, hasElimination]);
    const newTranscript = Crypto_hash2(state.transcriptHash, outcomeHash);

    const nextRound = (state.round + 1) as Uint<32>;
    const newState = GameState {
        adminKey: state.adminKey,
        adminVotePublicKey: state.adminVotePublicKey,
        phase: Phase.Night,
        round: nextRound,
        playerCount: state.playerCount,
        aliveCount: hasElimination ? (state.aliveCount - 1) as Uint<32> : state.aliveCount,
        werewolfCount: state.werewolfCount,
        villagerCount: state.villagerCount,
        aliveTreeRoot: state.aliveTreeRoot,
        masterSecretCommitment: state.masterSecretCommitment,
        transcriptHash: newTranscript
    };
    games.insert(gameId, newState);
}

// =========================================================================
// GAME END & VERIFICATION
// =========================================================================

export circuit revealRole(
    _gameId: Bytes<32>,
    _playerIdx: Uint<32>,
    _role: Uint<8>,
    _salt: Bytes<32>
): [] {
    const gameId = disclose(_gameId);
    const playerIdx = disclose(_playerIdx);
    const role = disclose(_role);
    const salt = disclose(_salt);

    const state = games.lookup(gameId);
    const roleCommitment = playerRoleCommitments.lookup(gameId).lookup(playerIdx);

    const calcCommit = Crypto_commitRole(role, salt);
    assert(calcCommit == roleCommitment, "Invalid role revelation");

    if (state.phase != Phase.Finished) {
        const roleEnum = role as Role;
        const isWolf = roleEnum == Role.Werewolf;
        
        const wwCount = isWolf 
            ? ((state.werewolfCount > 0 as Uint<32>) ? (state.werewolfCount - 1 as Uint<32>) : 0 as Uint<32>)
            : state.werewolfCount;

        const vilCount = !isWolf
            ? ((state.villagerCount > 0 as Uint<32>) ? (state.villagerCount - 1 as Uint<32>) : 0 as Uint<32>)
            : state.villagerCount;
        
        const isGameOver = (wwCount == 0 as Uint<32>) || (wwCount >= vilCount);
        const nextPhase = isGameOver ? Phase.Finished : state.phase;

        games.insert(disclose(gameId), GameState {
            ...state,
            phase: nextPhase,
            werewolfCount: wwCount,
            villagerCount: vilCount
        });
    }
}

export circuit endGame(
    _gameId: Bytes<32>,
    _masterSecret: Bytes<32>
): [] {
    const gameId = disclose(_gameId);
    const masterSecret = disclose(_masterSecret);

    const state = games.lookup(gameId);
    assert(std_ownPublicKey() == state.adminKey, "Only Admin");

    // Verify Secret against Commitment made in initGame
    const calculatedCommit = Crypto_hash(masterSecret);
    assert(calculatedCommit == state.masterSecretCommitment, "Invalid Master Secret for this Game");

    gameSecrets.insert(gameId, masterSecret);
    
    games.insert(disclose(gameId), GameState {
        ...state,
        phase: Phase.Finished
    });
}

export circuit verifyGameSetup(
    _gameId: Bytes<32>,
    _masterSecret: Bytes<32>,
    _playerIdx: Uint<32>,
    _assignedRole: Uint<8>
): Boolean {
    const gameId = disclose(_gameId);
    const masterSecret = disclose(_masterSecret);
    const playerIdx = disclose(_playerIdx);
    const assignedRole = disclose(_assignedRole);

    const state = games.lookup(gameId);
    
    // Check secret is valid for this game
    const calculatedCommit = Crypto_hash(masterSecret);
    if (calculatedCommit != state.masterSecretCommitment) return false;

    const saltSeed = std_persistentHash<[Bytes<32>, Bytes<32>, Uint<32>]>([
        masterSecret, 
        pad(32, "salt"), 
        playerIdx
    ]);
    const derivedSalt = saltSeed;

    const roleCommitment = playerRoleCommitments.lookup(gameId).lookup(playerIdx);
    const derivedCommit = Crypto_commitRole(assignedRole, derivedSalt);

    return derivedCommit == roleCommitment;
}

export circuit getEncryptedVotesForRound(
    _gameId: Bytes<32>,
    _phase: Phase,
    _round: Uint<32>
): Vector<10, Bytes<3>> {
    const gameId = disclose(_gameId);
    const phase = disclose(_phase);
    const round = disclose(_round);

    const roundPrefix = phase == Phase.Day ? pad(32, "day-round") : pad(32, "night-round");
    const countKey = Crypto_hash2(
        Crypto_hash2(gameId, roundPrefix),
        std_persistentHash<Uint<32>>(round)
    );

    const emptyVote = pad(3, "0");
    if (!roundEncryptedVotes.member(countKey)) {
        return [
            emptyVote, emptyVote, emptyVote, emptyVote, emptyVote,
            emptyVote, emptyVote, emptyVote, emptyVote, emptyVote
        ];
    }

    return [
        roundEncryptedVotes.lookup(countKey).member(0 as Uint<32>) ? roundEncryptedVotes.lookup(countKey).lookup(0 as Uint<32>) : emptyVote,
        roundEncryptedVotes.lookup(countKey).member(1 as Uint<32>) ? roundEncryptedVotes.lookup(countKey).lookup(1 as Uint<32>) : emptyVote,
        roundEncryptedVotes.lookup(countKey).member(2 as Uint<32>) ? roundEncryptedVotes.lookup(countKey).lookup(2 as Uint<32>) : emptyVote,
        roundEncryptedVotes.lookup(countKey).member(3 as Uint<32>) ? roundEncryptedVotes.lookup(countKey).lookup(3 as Uint<32>) : emptyVote,
        roundEncryptedVotes.lookup(countKey).member(4 as Uint<32>) ? roundEncryptedVotes.lookup(countKey).lookup(4 as Uint<32>) : emptyVote,
        roundEncryptedVotes.lookup(countKey).member(5 as Uint<32>) ? roundEncryptedVotes.lookup(countKey).lookup(5 as Uint<32>) : emptyVote,
        roundEncryptedVotes.lookup(countKey).member(6 as Uint<32>) ? roundEncryptedVotes.lookup(countKey).lookup(6 as Uint<32>) : emptyVote,
        roundEncryptedVotes.lookup(countKey).member(7 as Uint<32>) ? roundEncryptedVotes.lookup(countKey).lookup(7 as Uint<32>) : emptyVote,
        roundEncryptedVotes.lookup(countKey).member(8 as Uint<32>) ? roundEncryptedVotes.lookup(countKey).lookup(8 as Uint<32>) : emptyVote,
        roundEncryptedVotes.lookup(countKey).member(9 as Uint<32>) ? roundEncryptedVotes.lookup(countKey).lookup(9 as Uint<32>) : emptyVote
    ];
}

export circuit getGameAdminPublicKey(_gameId: Bytes<32>): Bytes<33> {
    const gameId = disclose(_gameId);
    assert(games.member(gameId), "Game not found");
    return games.lookup(gameId).adminVotePublicKey;
}

}