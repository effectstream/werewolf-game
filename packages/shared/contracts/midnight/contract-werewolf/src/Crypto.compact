module Crypto {
    import CompactStandardLibrary;
    import CompactStandardLibrary prefix std_;

    // Wrapper for persistent hashing
    export circuit hash(data: Bytes<32>): Bytes<32> {
        return std_persistentHash<Bytes<32>>(data);
    }
    
    export circuit hash2(a: Bytes<32>, b: Bytes<32>): Bytes<32> {
        return std_persistentHash<[Bytes<32>, Bytes<32>]>([a, b]);
    }

    export circuit commitRole(role: Uint<8>, salt: Bytes<32>): Bytes<32> {
        return std_persistentHash<[Uint<8>, Bytes<32>]>([role, salt]);
    }

    // Verifies a Merkle Proof for anonymous voting/actions
    export circuit verifyMerkleProof(root: MerkleTreeDigest, leaf: Bytes<32>, path: MerkleTreePath<10, Bytes<32>>): Boolean {
        // Ensure the leaf in the path matches the claim
        if (path.leaf != leaf) {
            return false;
        }
        // compute root and check
        return std_merkleTreePathRoot<10, Bytes<32>>(path) == root;
    }

    export circuit isValidPoint(p: CurvePoint): Boolean {
        return true; 
    }

    // Derives a Public Key (ZswapCoinPublicKey) from a Private Key (Bytes<32> Secret)
    // Used to verify the Master Secret at the end of the game matches the Admin Key
    export circuit derivePublicKey(secret: Bytes<32>): ZswapCoinPublicKey {
        // 1. Convert bytes to field scalar
        const scalar = std_degradeToTransient(secret);
        
        // 2. Compute Public Key Point: P = G * scalar
        const point = std_ecMulGenerator(scalar);
        
        // 3. Serialize point to Bytes<32> for ZswapCoinPublicKey format.
        // We hash the X/Y coordinates to produce a deterministic 32-byte representation.
        // The Admin must generate their keypair off-chain using this same logic.
        const pkBytes = std_persistentHash<[Field, Field]>([point.x, point.y]);
        
        return ZswapCoinPublicKey { bytes: pkBytes };
    }
}