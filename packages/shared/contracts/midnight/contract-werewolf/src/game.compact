// SPDX-License-Identifier: MIT
pragma language_version >= 0.19.0;

import CompactStandardLibrary;
import CompactStandardLibrary prefix std_;
import "./WerewolfTypes";
import "./Werewolf" prefix Werewolf_;
import "./Crypto" prefix Crypto_;

export { 
    Role, 
    Phase, 
    GameState 
};

export { 
    Werewolf_games, 
    Werewolf_playerAlive, 
    Werewolf_playerPublicKeys, 
    Werewolf_playerRoleCommitments, 
    Werewolf_playerEncryptedRoles, 
    Werewolf_voteNullifiers, 
    Werewolf_gameSecrets
};

constructor() {}

// Merged Create + Setup
export circuit createGame(
    gameId: Bytes<32>, 
    adminKey: ZswapCoinPublicKey,
    adminVotePublicKey: Bytes<33>,
    masterSecretCommitment: Bytes<32>,
    actualCount: Uint<32>,
    werewolfCount: Uint<32>,
    initialRoot: MerkleTreeDigest
): [] {
    return Werewolf_createAndSetupGame(
        disclose(gameId), 
        disclose(adminKey), 
        disclose(adminVotePublicKey),
        disclose(masterSecretCommitment), 
        disclose(actualCount), 
        disclose(werewolfCount), 
        disclose(initialRoot)
    );
}

export circuit forceEndGame(
    gameId: Bytes<32>,
    masterSecret: Bytes<32>
): [] {
    return Werewolf_endGame(gameId, masterSecret);
}

// Action using Witness
export circuit nightAction(
    gameId: Bytes<32>
): [] {
    return Werewolf_submitNightAction(gameId);
}

export circuit resolveNightPhase(
    gameId: Bytes<32>,
    newRound: Uint<32>,
    deadPlayerIdx: Uint<32>, 
    hasDeath: Boolean,
    newMerkleRoot: MerkleTreeDigest
): [] {
    return Werewolf_resolveNight(
        gameId, 
        newRound, 
        deadPlayerIdx, 
        hasDeath, 
        newMerkleRoot
    );
}

// Action using Witness
export circuit voteDay(
    gameId: Bytes<32>
): [] {
    return Werewolf_castDayVote(gameId);
}

export circuit resolveDayPhase(
    gameId: Bytes<32>,
    eliminatedIdx: Uint<32>,
    hasElimination: Boolean
): [] {
    return Werewolf_resolveDay(gameId, eliminatedIdx, hasElimination);
}

export circuit revealPlayerRole(
    gameId: Bytes<32>,
    playerIdx: Uint<32>,
    role: Uint<8>,
    salt: Bytes<32>
): [] {
    return Werewolf_revealRole(gameId, playerIdx, role, salt);
}

export circuit verifyFairness(
    gameId: Bytes<32>,
    masterSecret: Bytes<32>,
    playerIdx: Uint<32>,
    assignedRole: Uint<8>
): Boolean {
    return Werewolf_verifyGameSetup(
        gameId, 
        masterSecret, 
        playerIdx, 
        assignedRole
    );
}

export circuit getEncryptedVotesForRound(
    gameId: Bytes<32>,
    phase: Phase,
    round: Uint<32>
): Vector<10, Bytes<129>> {
    return Werewolf_getEncryptedVotesForRound(gameId, phase, round);
}

// ============================================
// HELPERS & TEST UTILS
// ============================================

export circuit getGameState(gameId: Bytes<32>): GameState {
    const gid = disclose(gameId);
    assert(Werewolf_games.member(gid), "Game not found");
    return Werewolf_games.lookup(gid);
}

export circuit isPlayerAlive(gameId: Bytes<32>, playerIdx: Uint<32>): Boolean {
    const gid = disclose(gameId);
    return Werewolf_playerAlive.lookup(gid).lookup(disclose(playerIdx));
}

export circuit getAdminKey(): ZswapCoinPublicKey {
    return Werewolf_getAdminKey();
}

export circuit getGameAdminPublicKey(gameId: Bytes<32>): Bytes<33> {
    return Werewolf_getGameAdminPublicKey(gameId);
}

// These are required by ww.test.ts to setup simulation state consistent with the contract logic
export circuit testComputeCommitment(role: Uint<8>, salt: Bytes<32>): Bytes<32> {
    return Crypto_commitRole(role, salt);
}

export circuit testComputeHash(data: Bytes<32>): Bytes<32> {
    return Crypto_hash(data);
}

export circuit testComputeSalt(masterSecret: Bytes<32>, playerIdx: Uint<32>): Bytes<32> {
    return std_persistentHash<[Bytes<32>, Bytes<32>, Uint<32>]>([
        masterSecret,
        pad(32, "salt"),
        playerIdx
    ]);
}

// Internal struct for leaf preimage (matches what std_merkleTreePathRoot uses)
struct LeafPreimage {
    domain_sep: Bytes<6>,
    data: Bytes<32>
}

// Calculates digest for a Leaf (Bytes32)
// This MUST match what std_merkleTreePathRoot uses internally: 
// degradeToTransient(persistentHash({ domain_sep: "mdn:lh", data: leaf }))
export circuit testLeafDigest(data: Bytes<32>): MerkleTreeDigest {
    const preimage = LeafPreimage {
        domain_sep: pad(6, "mdn:lh"),
        data: data
    };
    return MerkleTreeDigest { 
        field: std_degradeToTransient(std_persistentHash<LeafPreimage>(preimage))
    };
}

// Calculates digest for an Internal Node
// This MUST match what std_merkleTreePathRoot uses internally:
// transientHash<[Field, Field]>([left.field, right.field])
export circuit testNodeDigest(left: MerkleTreeDigest, right: MerkleTreeDigest): MerkleTreeDigest {
    return MerkleTreeDigest { 
        field: std_transientHash<[Field, Field]>([left.field, right.field]) 
    };
}

// Verify proof off-chain logic using on-chain circuit
export circuit testVerifyMerkleProof(
    root: MerkleTreeDigest, 
    leaf: Bytes<32>, 
    path: MerkleTreePath<10, Bytes<32>>
): Boolean {
    return Crypto_verifyMerkleProof(root, leaf, path);
}

// DEBUG: Calculate Root from Path (to compare with simulation)
export circuit testMerkleRoot(path: MerkleTreePath<10, Bytes<32>>): MerkleTreeDigest {
    return std_merkleTreePathRoot<10, Bytes<32>>(path);
}