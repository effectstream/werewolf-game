import type { Pool } from "pg";
import { runPreparedQuery } from "@paimaexample/db";
import {
  closeLobby,
  getGameView,
  getLobby,
  getLobbyPlayers,
  insertLobbyPlayer,
  incrementLobbyPlayerCount,
  upsertLobby,
} from "@werewolf-game/database";

const CHAT_SERVER_URL = Deno.env.get("CHAT_SERVER_URL") ?? "http://localhost:3001";

function chatPost(path: string, body: unknown): void {
  void fetch(`${CHAT_SERVER_URL}${path}`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body),
  }).catch((err) => console.warn(`[chat] POST ${path} failed:`, err));
}

// ---------------------------------------------------------------------------
// In-memory bundle store. Maps gameId → shuffled queue of PlayerBundle objects.
// Bundles are generated by the Trusted Node (App.tsx) at game creation time and
// pushed here. Each joining player pops one bundle from the queue.
//
// TODO: validate werewolfCount >= 2 server-side once werewolfCount is included
// in the create_game payload.
// ---------------------------------------------------------------------------

type PlayerBundle = {
  gameId: string;
  playerId: number;
  leafSecret: string;
  merklePath: { sibling: { field: string }; goes_left: boolean }[];
  adminVotePublicKeyHex: string;
  role?: number;
};

const bundleStore = new Map<number, PlayerBundle[]>();

export async function createGameHandler(
  dbConn: Pool,
  gameId: number,
  maxPlayers: number,
  playerBundles: PlayerBundle[],
) {
  if (maxPlayers < 5) {
    throw Object.assign(new Error("Minimum 5 players required."), { statusCode: 400 });
  }

  await runPreparedQuery(
    upsertLobby.run({ game_id: gameId, max_players: maxPlayers, created_block: 0 }, dbConn),
    "upsertLobby",
  );

  // Store the pre-shuffled bundles. The Trusted Node shuffles roles before
  // computing bundles, so the queue is already in random order.
  bundleStore.set(gameId, [...playerBundles]);
  console.log(`[lobby] Stored ${playerBundles.length} bundles for game=${gameId}`);

  return {
    gameId,
    state: "Open" as const,
  };
}

export async function joinGameHandler(
  dbConn: Pool,
  gameId: number,
  midnightAddressHash: string,
) {
  // Guard: game must exist in bundle store (i.e. createGame was called first).
  if (!bundleStore.has(gameId)) {
    throw Object.assign(
      new Error("Game not found or already started."),
      { statusCode: 409 },
    );
  }

  // Guard: prevent double-join consuming a second bundle.
  const existingPlayers = await runPreparedQuery(
    getLobbyPlayers.run({ game_id: gameId }, dbConn),
    "getLobbyPlayers",
  );
  const alreadyJoined = existingPlayers.some(
    (p) => p.midnight_address_hash === midnightAddressHash,
  );
  if (alreadyJoined) {
    return { success: true, message: "Already joined." };
  }

  await runPreparedQuery(
    insertLobbyPlayer.run({ game_id: gameId, midnight_address_hash: midnightAddressHash, joined_block: 0 }, dbConn),
    "insertLobbyPlayer",
  );
  await runPreparedQuery(
    incrementLobbyPlayerCount.run({ game_id: gameId }, dbConn),
    "incrementLobbyPlayerCount",
  );

  const queue = bundleStore.get(gameId)!;
  const bundle = queue.pop();

  let gameStarted = false;

  if (queue.length === 0) {
    // Last slot filled — start the game.
    bundleStore.delete(gameId);
    await runPreparedQuery(closeLobby.run({ game_id: gameId }, dbConn), "closeLobby");
    chatPost("/broadcast", {
      gameId,
      text: "GAME_STARTED: All players have joined. The game begins now.",
    });
    gameStarted = true;
    console.log(`[lobby] Game ${gameId} started — all slots filled.`);
  }

  return { success: true, bundle, gameStarted };
}

export async function closeGameHandler(dbConn: Pool, gameId: number) {
  await runPreparedQuery(
    closeLobby.run({ game_id: gameId }, dbConn),
    "closeLobby",
  );
  return { success: true };
}

export async function getGameStateHandler(dbConn: Pool, gameId: number) {
  const lobbyRows = await runPreparedQuery(
    getLobby.run({ game_id: gameId }, dbConn),
    "getLobby",
  );
  if (lobbyRows.length === 0) {
    throw new Error(`Game ${gameId} not found`);
  }
  const lobby = lobbyRows[0];
  return {
    id: typeof lobby.game_id === 'string' ? Number(lobby.game_id) : lobby.game_id,
    state: lobby.closed ? ("Closed" as const) : ("Open" as const),
    playerCount: typeof lobby.player_count === 'string' ? Number(lobby.player_count) : lobby.player_count,
    maxPlayers: typeof lobby.max_players === 'string' ? Number(lobby.max_players) : lobby.max_players,
  };
}

export async function getPlayersHandler(dbConn: Pool, gameId: number) {
  const players = await runPreparedQuery(
    getLobbyPlayers.run({ game_id: gameId }, dbConn),
    "getLobbyPlayers",
  );
  return {
    gameId,
    players: players.map((p) => ({
      // evmAddress is not stored in the DB — it is only available on-chain via
      // the PlayerJoined event. Callers that need EVM addresses should read
      // getPlayers() directly from the EVM contract.
      evmAddress: "",
      midnightAddressHash: p.midnight_address_hash,
    })),
  };
}

export async function getGameViewHandler(dbConn: Pool, gameId: number) {
  const rows = await runPreparedQuery(
    getGameView.run({ game_id: gameId }, dbConn),
    "getGameView",
  );

  if (rows.length === 0) {
    throw new Error(`Game view for game ${gameId} not found`);
  }

  const row = rows[0];
  const aliveVector: boolean[] = JSON.parse(row.alive_vector);
  const werewolfIndicesRaw: number[] = JSON.parse(row.werewolf_indices);

  const players = aliveVector.map((alive, index) => ({
    index,
    alive,
  }));

  // Only expose werewolf indices if the game is finished (defense in depth)
  const werewolfIndices = row.finished ? werewolfIndicesRaw : [];

  return {
    gameId: typeof row.game_id === "string" ? Number(row.game_id) : row.game_id,
    phase: row.phase,
    round: row.round,
    playerCount: row.player_count,
    aliveCount: row.alive_count,
    werewolfCount: row.werewolf_count,
    villagerCount: row.villager_count,
    players,
    finished: row.finished,
    werewolfIndices,
    updatedBlock:
      typeof row.updated_block === "string"
        ? Number(row.updated_block)
        : row.updated_block,
  };
}
